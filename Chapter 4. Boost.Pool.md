# Глава 4. Boost.Pool

[Boost.Pool](http://www.boost.org/doc/libs/1_62_0/libs/pool/doc/html/index.html) - библиотека, которая содержит несколько классов, для управления памятью. В то время как программы C++ обычно используют `new` чтобы выделять память динамически, подробности того, как выделяется память, зависят от реализации стандартной библиотеки и операционной системы. С помощью Boost.Pool вы можете, например, ускорить процесс управления памятью, чтобы работа с памятью в вашей программе происходила быстрее.

Boost.Pool не изменяет поведение `new` или операционной системы. Boost.Pool работает, потому что управляемая память запрашивается из операционной системы в первую очередь – например, с помощью `new`. С внешней стороны ваша программа уже выделила память, но внутренне память еще не требуется и передана Boost.Pool для управления ею.

Boost.Pool разделяет сегменты памяти с одинаковым размером. Каждый раз, когда вы запрашиваете память от Boost.Pool, библиотека получает доступ к следующему свободному сегменту и выделяет память из этого сегмента для вас. Весь сегмент тогда отмечен, как используемый, независимо от того, в каком количестве байтов данного сегмента вы фактически.

Это понятие управления памятью называют **простой сегрегацией хранения**. Это единственное понятие, поддерживаемое Boost.Pool. Это  особенно полезно, если много объектов одного размера должны создаваться и часто уничтожаться. В этом случае требуемая память может выделяться и  быстро освобождаться.

Boost.Pool предоставляет класс `boost::simple_segregated_storage` для создания и управления сегрегированной памятью. `boost::simple_segregated_storage` класс низкого уровня, который вы обычно не будете использовать в своих программах напрямую. Он используется только в [примере 4.1](#ex.simple_segregated_storage_01), чтобы проиллюстрировать простое сегрегированное хранение. Все остальные классы от Boost.Pool внутренне основаны на `boost::simple_segregated_storag`.

<a id="ex.simple_segregated_storage_01"></a>
### Пример 4.1. Использование `boost::simple_segregated_storage`
```cpp
#include <boost/pool/singleton_pool.hpp>

struct int_pool {};
typedef boost::singleton_pool<int_pool, sizeof(int)> singleton_int_pool;

int main()
{
  int *i = static_cast<int*>(singleton_int_pool::malloc());
  *i = 1;

  int *j = static_cast<int*>(singleton_int_pool::ordered_malloc(10));
  j[9] = 2;

  singleton_int_pool::release_memory();
  singleton_int_pool::purge_memory();
}
```
Заголовочный файл **boost/pool/simple_segregated_storage.hpp** должен быть включен, чтобы использовать шаблон класса `boost::simple_segregated_storage`. [Пример 4.1](#ex.simple_segregated_storage_01) передачи `std::size_t` как шаблонный параметр. Этот параметр определяет, который тип должен использоваться для чисел, переданных функциям-членам из `boost::simple_segregated_storage` ссылающихся на, например, размер сегмента. Практическая уместность этого шаблонного параметра довольно низкая.

Более интересные функции-члены вызываются из `boost::simple_segregated_storage`. Во-первых, `add_block()` вызвается, чтобы передать блок памяти с 1024 байтами в **хранилище**. Память обеспечивается вектором **v**. Третий параметр, который передается `add_block()`, определяет, что блок памяти должен быть разделен на сегменты по 256 байтов каждый. Поскольку общий размер блока памяти составляет 1024 байта, память, которой управляет **хранилище**, состоит из четырех сегментов.

Вызов `malloc()` и `malloc_n()` запрашивает место в `хранилище`. В то время как `malloc()` возвращает указатель на свободный сегмент, `malloc_n()` возвращает указатель на один или несколько смежных сегментов, которые обеспечивают количество байтов в одном блоке согласно забросу. [Пример 4.1](#ex.simple_segregated_storage_01) запрашивает блок с 512 байтами с помощью `malloc_n()`. Этот вызов использует два сегмента, так как каждый сегмент составляет 256 байтов. После вызова `malloc()` и `malloc_n()`, **хранилище** имеет только один неиспользованный сегмент в запасе.

В конце примера все сегменты освобождены с помощью `free()` и `free_n()`. После этих двух вызовов все сегменты доступны и могут запрошены повторно с помощью `malloc()` или `malloc_n()`.

Вы обычно не используете `boost::simple_segregated_storage` непосредственно. Boost.Pool обеспечивает другие классы, которые выделяют память автоматически, не требуя, чтобы Вы выделили память сами и передали ее  `boost::simple_segregated_storage`.

<a id="ex.object_pool_01"></a>
### Пример 4.2. Использование `boost::object_pool`

```cpp
#include <boost/pool/object_pool.hpp>

int main()
{
  boost::object_pool<int> pool;

  int *i = pool.malloc();
  *i = 1;

  int *j = pool.construct(2);

  pool.destroy(i);
  pool.destroy(j);
}
```
