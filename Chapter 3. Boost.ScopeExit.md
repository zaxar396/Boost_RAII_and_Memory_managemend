# Глава 3. Boost.ScopeExit

Библиотека Boost.ScopeExit позволяет использовать RAII без специфичных для ресурса классов.

<a id="ex.boost::BOOST_SCOPE_EXIT_01"></a>
### Использование `BOOST_SCOPE_EXIT`
```cpp
#include <boost/scope_exit.hpp>
#include <iostream>

int *foo()
{
  int *i = new int{10};
  BOOST_SCOPE_EXIT(&i)
  {
    delete i;
    i = 0;
  } BOOST_SCOPE_EXIT_END
  std::cout << *i << '\n';
  return i;
}

int main()
{
  int *j = foo();
  std::cout << j << '\n';
}
```

Boost.ScopeExit предоставляет макрос `Boost_SCOPE_EXIT`, который может быть использован для определения чего-либо, похожего на локальную функцию, но не имеющего названия. Однако, есть список параметров в круглых скобках и блок в фигурных скобках.

Для использования `BOOST_SCOPE_EXIT` нужно подключить boost/scoped_exit.hpp.

Список параметров для макроса содержит переменные из внешней области, которые должны быть доступны в блоке. Переменные копируются. Чтобы передать переменную по ссылке, она должна начинаться с амперсанда, как и в [примере 3.1. ](#ex.BOOST_SCOPE_EXIT_01).

Код в блоке может получить доступ к переменным из внешней области видимости, если переменные находятся в списке параметров.

`BOOST_SCOPE_EXIT` используется для определения блока, который будет выполняться, когда границы блока определяются в концах. В [примере 3.1. ](#ex.BOOST_SCOPE_EXIT_01) блок, определенный с помощью `BOOST_SCOPE_EXIT`, выполняется незадолго до того, как `foo()` вернет значение.

`BOOST_SCOPE_EXIT` может быть использован для получения выгоды от RAII без использования ресурсов конкретных классов. `foo()` использует `new` для создания `int` переменной. Для того , чтобы освободить переменную, блок , который требует `delete`, определяется с `BOOST_SCOPE_EXIT`. Этот блок гарантированно будет выполнен, даже если, например, функция возвращает значение раньше времени из-за исключения. В [примере 3.1. ](#ex.BOOST_SCOPE_EXIT_01) `BOOST_SMART_POINTER` хороший умный указатель.

Обратите внимание, что переменная **i** принимает значение 0 в конце блока, определенного `BOOST_SCOPE_EXIT`. Затем `foo()` возвращает **i** и записывает данную переменную в стандартный поток вывода в `main()`. Тем не менее, в примере не отображается 0. **j** принимает случайное значение, а именно - адрес, по которому можно было определить `int` переменную до того, как память была освобождена. Блок перед `BOOST_SCOPE_EXIT` получил ссылку на **i** и освободил память. Но так как блок выполняется в конце `foo()`, присвоение **i** значения 0 происходит слишком поздно. Возвращаемое значение `foo()` является копией **i**, которая создается раньше, чем **i** присваивается 0.

Вы можете игнорировать Boost.ScopeExit, если вы используете возможности C++11. В этом случае, вы можете использовать RAII без ресурсов конкретных классов с помощью лямбда - функций.

<a id="ex.lambda_01"></a>      
### Пример 3.2. Boost.ScopeExit с C++11 лямбда функциями
cpp`
#include <iostream>
#include <utility>

template <typename T>
struct scope_exit
{
  scope_exit(T &&t) : t_{std::move(t)} {}
  ~scope_exit() { t_(); }
  T t_;
};

template <typename T>
scope_exit<T> make_scope_exit(T &&t) { return scope_exit<T>{
  std::move(t)}; }

int *foo()
{
  int *i = new int{10};
  auto cleanup = make_scope_exit([&i]() mutable { delete i; i = 0; });
  std::cout << *i << '\n';
  return i;
}

int main()
{
  int *j = foo();
  std::cout << j << '\n';
}
```

В [примере 3.2. ](#ex.lambda_01) определяется класс `scope_exit`, конструктор которого принимает функцию.Эта функция вызывается деструктором. Кроме того, вспомогательная функция, `make_scope_exit()``, определяется, что позволяет создать экземпляр `scope_exit` без необходимости указывать параметр шаблона.

В `foo()` функция лямбда передается через make_scope_exit(). Лямбда функция выглядит как блок после `BOOST_SCOPE_EXIT` в [примере 3.1. ](#ex.BOOST_SCOPE_EXIT_01): динамически выделяемая `int` переменная, адрес которой хранится в **i** освобождается с помощью оператора  `delete`. Тогда **i** присваивается значение 0.

В данном примере происходит то же самое, что и в  предыдущем. Не только `int` переменная удаляется, но и **j** не принимает значение 0, когда он записывается в стандартный поток вывода.

<a id="ex.Peculiarities_01"></a>
### Особенности `BOOST_SCOPE_EXIT`
```cpp
#include <boost/scope_exit.hpp>
#include <iostream>

struct x
{
  int i;

  void foo()
  {
    i = 10;
    BOOST_SCOPE_EXIT(void)
    {
      std::cout << "last\n";
    } BOOST_SCOPE_EXIT_END
    BOOST_SCOPE_EXIT(this_)
    {
      this_->i = 20;
      std::cout << "first\n";
    } BOOST_SCOPE_EXIT_END
  }
};

int main()
{
  x obj;
  obj.foo();
  std::cout << obj.i << '\n';
}
```
[Пример 3.3. ](#ex.Peculiarities_01) показывает некоторые особенности `BOOST_SCOPE_EXIT`:
* Когда `BOOST_SCOPE_EXIT` используется для определения более одного блока, блоки выполняются в обратном порядке. [Пример 3.3. ](#ex.Peculiarities_01) показывает **first** следует за **last**.
* Если переменные не будут переданы `BOOST_SCOPE_EXIT`, то вам необходимо указать тип `void`. Скобки не должны быть пустыми.
* Если вы используете `BOOST_SCOPE_EXIT` в функции, и вам необходимо передать указатель на текущий объект, вы должны использовать **this_**, не `this`.

[Пример 3.3. ](#ex.Peculiarities_01) показывает **first**,**last**, и **20** в данном порядке.     
