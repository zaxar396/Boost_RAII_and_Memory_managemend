# Глава 1. Boost.SmartPointers
## Содержание
...

Библиотека [Boost.SmartPointers](http://www.boost.org/doc/libs/1_62_0/libs/smart_ptr/smart_ptr.htm) предоставляет различные умные указатели. Они помогают вам управлять динамически выделенными объектами, закрепленными в умных указателях, которые высвобождают динамически выделенные объекты в деструкторе. Так как деструкторы срабатывают , когда заканчиваются границы интелектуальных указателей, то высвобождение динамических объектов гарантируется. Не может быть утечки памяти, если, например, вы забыли вызвать оператор `delete`.  


Стандартная библиотека включает в себя умный указатель `std::auto_ptr` еще с C++98, но в стандарте C++11 `std::auto_ptr` устарел. С выходом стандарта C++11 в стандартной библиотеке появились новые и усовершенствованные умные указатели. `std::shared_ptr` и `std::weak_ptr` возникли в Boost.SmartPointers и названы в этой библиотеке, как `boost::shared_ptr` и `boost::weak_ptr`. Не существует двойника `std::unique_ptr`. Однако, Boost.SmartPointers предоставляет четыре дополнительных умных указателя -       `boost::scoped_ptr`,`boost::scoped_array`,`boost::shared_array` и `boost::intrusive_ptr` - которых нет в стандартной библиотеке.


# Единоличное владение
`boost::scoped_ptr` - это умный указатель, который является единственным владельцем динамически выделенного объекта.`boost::scoped_ptr` не может быть скопирован или перемещен. Данный умный указатель определен в заголовочном файле ```cpp boost/scoped_ptr.hpp ```.

<a id="ex.scoped_ptr_01"></a>
### Пример 1.1. Использование `boost::scoped_ptr`

```cpp
#include <boost/scoped_ptr.hpp>
#include <iostream>

int main()
{
  boost::scoped_ptr<int> p{new int{1}};
  std::cout << *p << '\n';
  p.reset(new int{2});
  std::cout << *p.get() << '\n';
  p.reset();
  std::cout << std::boolalpha << static_cast<bool>(p) << '\n';
}
```
Умный указатель типа `boost::scoped_ptr` не может передавать права собственности на объект. После инициализации объекта с адресом, динамически выделенный объект освобаждается, когда выполняется деструктор или при вызове функции `reset()`.

[Пример 1.1](#ex.scoped_ptr_01) использует умный указатель **p** с типом `boost::scoped_ptr<int>`. **p** инициализируется с указателем на динамически выделенный объект, который хранит в себе значение 1. С помощью `operator*`происходит разыменовывание **p** , и **1** записывается в стандартный вывод.

С помощью `reset()` новый адрес может быть сохранен в умный указатель. В данном примере адрес недавно выделенного `int` объекта со значением 2 передается в p. С вызовом `reset()`, объект, на который в настоящее время ссылается **p**, автоматически уничтожается.

`get()` возвращает адрес объекта, связанного с умным указателем. В примере происходит разыменовывание адреса, возвращаемого `get()`, для записи **2** в стандартный вывод.

`boost::scoped_ptr`перегружает оператор `operator bool`. `operator bool` возвращает `true`, если умный указатель содержит ссылку на объект - то есть, если он не пустой. Пример выводит **false** в стандартный вывод, так как **p** сброшен при вызове `reset()`.

Деструктор `boost::scoped_ptr`освобождает ссылочный объект с помощью `delete`. Вот почему `boost::scoped_ptr`не должен быть инициализирован с адресом динамически выделенного массива, который должен быть освобожден с помощью `delete[]`. Для массивов Boost.SmartPointersсодержит класс `boost::scoped_array`.

[Пример 1.2](#ex.scoped_array_01) использование `boost::scoped_array`
```cpp
#include <boost/scoped_array.hpp>

int main()
{
  boost::scoped_array<int> p{new int[2]};
  *p.get() = 1;
  p[1] = 2;
  p.reset(new int[3]);
}
```
Умный указатель `boost::scoped_array` используется как `boost::scoped_ptr`. Важным отличием является то , что деструктор `boost::scoped_array` использует оператор `delete[]` для освобождения объекта. Потому что данный оператор относится только к массивам, `boost::scoped_array` должен быть инициализирован с адресом динамически выделенного массива.

`boost::scoped_array` определен в ```cpp boost/scoped_array.hpp ```.

`boost::scoped_array` обеспечивает перегрузку для `operator[]` и `operator bool`. Используя `operator[]` можно получить конкретный элемент массива. Таким образом, объект типа ` boost::scoped_array` ведет себя как массив , которым он владеет. [Пример 1.2](#ex.scoped_array_01) сохраняет число 2 , как 2 элемент в массиве, на который ссылается **p**.

Как и `boost::scoped_ptr`, функции `get()` и `reset()` предназначены для извлечения и повторной инициализации адреса содержащегося в ней объекта.

# Общее владение
Умный указатель `boost::shared_ptr` похож на `boost::scoped_ptr`. Основное различие заключается в том , что `boost::shared_ptr` не обязательно является исключительным владельцем объекта. Объект может использоваться совместно с другими умными указателями типа `boost::shared_ptr`. В таком случае, общий объект не освобождается, пока не будет уничтожена последняя копия общего указателя, ссылающегося на объект. Поскольку `boost::shared_ptr` может делить право на владение объектом, умный указатель может быть скопирован, что невозможно с `boost::scoped_ptr`.

`boost::shared_ptr`определен в заголовочном файле boost/shared_ptr.hpp.

[Пример 1.3](#ex.shared_ptr_01) Использование `boost::shared_ptr`

```cpp     
#include <boost/shared_ptr.hpp>
#include <iostream>

int main()
{
  boost::shared_ptr<int> p1{new int{1}};
  std::cout << *p1 << '\n';
  boost::shared_ptr<int> p2{p1};
  p1.reset(new int{2});
  std::cout << *p1.get() << '\n';
  p1.reset();
  std::cout << std::boolalpha << static_cast<bool>(p2) << '\n';
}
```

[Пример 1.3](#ex.shared_ptr_01) использует два умных указателя, p1 и p2, типа `boost::shared_ptr`. p2 инициализируется с p1 , это означает , что оба умные указатели владельцы одного и того же `int` объекта. Когда `reset()` вызывается для p1, новый `int` объект привязывается в p1. Это вовсе не означает , что существующий `int` объект разрушается. Так как он также закреплен в p2, он продолжает существовать. После вызова reset() , p1 является единственным владельцем `int` объекта с номером 2, и **р2** является единственным владельцем `int` объекта с номером 1.  

`boost::shared_ptr`использует счетчик ссылок. Только тогда , когда `boost::shared_ptr`обнаруживает , что последняя копия умного указателя была разрушена, объект освобождается с помощью `delete`.

Как `boost::scoped_ptr` , так и `boost::shared_ptr` перегружает `operator bool()`, `operator*()` , `operator->()`. Функции - члены `get()` и `reset()` предназначены для получения сохраненного адреса или сохранения новый.

 Deleter может быть передан в конструктор boost::shared_ptr,в качестве второго параметра. Deleter должнен быть функцией или функциональным объектом, который принимает в качестве единственного параметра инстанциированный указатель от типа boost::shared_ptr Deleter вызывается в деструкторе вместо `delete`. Это дает возможность управлять другими ресурсами, как динамически выделенными объектами в `boost::shared_ptr`.
